// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoData.proto

#ifndef PROTOBUF_ProtoData_2eproto__INCLUDED
#define PROTOBUF_ProtoData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace fantasybit {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ProtoData_2eproto();
void protobuf_AssignDesc_ProtoData_2eproto();
void protobuf_ShutdownFile_ProtoData_2eproto();

class MyFantasyName;
class Secret;
class FantasyNameT;
class BitStake;
class NameTransaction;
class OutData;
class InData;
class Transaction;
class NameTrans;
class FantasyPlayerPoints;
class ProjectionTrans;
class ResultTrans;
class SignedTransaction;
class BlockHeader;
class Block;
class SignedBlock;

enum OutData_Type {
  OutData_Type_MYFANTASYNAME = 1,
  OutData_Type_SNAPSHOT = 2,
  OutData_Type_HEARTBEAT = 3
};
bool OutData_Type_IsValid(int value);
const OutData_Type OutData_Type_Type_MIN = OutData_Type_MYFANTASYNAME;
const OutData_Type OutData_Type_Type_MAX = OutData_Type_HEARTBEAT;
const int OutData_Type_Type_ARRAYSIZE = OutData_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* OutData_Type_descriptor();
inline const ::std::string& OutData_Type_Name(OutData_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    OutData_Type_descriptor(), value);
}
inline bool OutData_Type_Parse(
    const ::std::string& name, OutData_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OutData_Type>(
    OutData_Type_descriptor(), name, value);
}
enum InData_Type {
  InData_Type_MINENAME = 1,
  InData_Type_QUIT = 2,
  InData_Type_HEARTBEAT = 3,
  InData_Type_CONNECT = 4,
  InData_Type_MAKE_BLOCK = 5
};
bool InData_Type_IsValid(int value);
const InData_Type InData_Type_Type_MIN = InData_Type_MINENAME;
const InData_Type InData_Type_Type_MAX = InData_Type_MAKE_BLOCK;
const int InData_Type_Type_ARRAYSIZE = InData_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* InData_Type_descriptor();
inline const ::std::string& InData_Type_Name(InData_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    InData_Type_descriptor(), value);
}
inline bool InData_Type_Parse(
    const ::std::string& name, InData_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InData_Type>(
    InData_Type_descriptor(), name, value);
}
enum MyNameStatus {
  none = 1,
  notavil = 2,
  requested = 5,
  found = 10,
  transaction_sent = 15,
  confirmed = 20
};
bool MyNameStatus_IsValid(int value);
const MyNameStatus MyNameStatus_MIN = none;
const MyNameStatus MyNameStatus_MAX = confirmed;
const int MyNameStatus_ARRAYSIZE = MyNameStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* MyNameStatus_descriptor();
inline const ::std::string& MyNameStatus_Name(MyNameStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    MyNameStatus_descriptor(), value);
}
inline bool MyNameStatus_Parse(
    const ::std::string& name, MyNameStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MyNameStatus>(
    MyNameStatus_descriptor(), name, value);
}
enum TransType {
  NAME = 0,
  PROJECTION = 1,
  RESULT = 2
};
bool TransType_IsValid(int value);
const TransType TransType_MIN = NAME;
const TransType TransType_MAX = RESULT;
const int TransType_ARRAYSIZE = TransType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TransType_descriptor();
inline const ::std::string& TransType_Name(TransType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TransType_descriptor(), value);
}
inline bool TransType_Parse(
    const ::std::string& name, TransType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TransType>(
    TransType_descriptor(), name, value);
}
// ===================================================================

class MyFantasyName : public ::google::protobuf::Message {
 public:
  MyFantasyName();
  virtual ~MyFantasyName();

  MyFantasyName(const MyFantasyName& from);

  inline MyFantasyName& operator=(const MyFantasyName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MyFantasyName& default_instance();

  void Swap(MyFantasyName* other);

  // implements Message ----------------------------------------------

  MyFantasyName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MyFantasyName& from);
  void MergeFrom(const MyFantasyName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .fantasybit.MyNameStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fantasybit::MyNameStatus status() const;
  inline void set_status(::fantasybit::MyNameStatus value);

  // optional .fantasybit.NameTransaction nametransaction = 3;
  inline bool has_nametransaction() const;
  inline void clear_nametransaction();
  static const int kNametransactionFieldNumber = 3;
  inline const ::fantasybit::NameTransaction& nametransaction() const;
  inline ::fantasybit::NameTransaction* mutable_nametransaction();
  inline ::fantasybit::NameTransaction* release_nametransaction();
  inline void set_allocated_nametransaction(::fantasybit::NameTransaction* nametransaction);

  // @@protoc_insertion_point(class_scope:fantasybit.MyFantasyName)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_nametransaction();
  inline void clear_has_nametransaction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::fantasybit::NameTransaction* nametransaction_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static MyFantasyName* default_instance_;
};
// -------------------------------------------------------------------

class Secret : public ::google::protobuf::Message {
 public:
  Secret();
  virtual ~Secret();

  Secret(const Secret& from);

  inline Secret& operator=(const Secret& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Secret& default_instance();

  void Swap(Secret* other);

  // implements Message ----------------------------------------------

  Secret* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Secret& from);
  void MergeFrom(const Secret& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string private_key = 1;
  inline bool has_private_key() const;
  inline void clear_private_key();
  static const int kPrivateKeyFieldNumber = 1;
  inline const ::std::string& private_key() const;
  inline void set_private_key(const ::std::string& value);
  inline void set_private_key(const char* value);
  inline void set_private_key(const char* value, size_t size);
  inline ::std::string* mutable_private_key();
  inline ::std::string* release_private_key();
  inline void set_allocated_private_key(::std::string* private_key);

  // optional .fantasybit.MyFantasyName myfantasyname = 2;
  inline bool has_myfantasyname() const;
  inline void clear_myfantasyname();
  static const int kMyfantasynameFieldNumber = 2;
  inline const ::fantasybit::MyFantasyName& myfantasyname() const;
  inline ::fantasybit::MyFantasyName* mutable_myfantasyname();
  inline ::fantasybit::MyFantasyName* release_myfantasyname();
  inline void set_allocated_myfantasyname(::fantasybit::MyFantasyName* myfantasyname);

  // @@protoc_insertion_point(class_scope:fantasybit.Secret)
 private:
  inline void set_has_private_key();
  inline void clear_has_private_key();
  inline void set_has_myfantasyname();
  inline void clear_has_myfantasyname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* private_key_;
  ::fantasybit::MyFantasyName* myfantasyname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static Secret* default_instance_;
};
// -------------------------------------------------------------------

class FantasyNameT : public ::google::protobuf::Message {
 public:
  FantasyNameT();
  virtual ~FantasyNameT();

  FantasyNameT(const FantasyNameT& from);

  inline FantasyNameT& operator=(const FantasyNameT& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FantasyNameT& default_instance();

  void Swap(FantasyNameT* other);

  // implements Message ----------------------------------------------

  FantasyNameT* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FantasyNameT& from);
  void MergeFrom(const FantasyNameT& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string public_key = 1;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 1;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const char* value, size_t size);
  inline ::std::string* mutable_public_key();
  inline ::std::string* release_public_key();
  inline void set_allocated_public_key(::std::string* public_key);

  // required string hash = 2;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 2;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const char* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  inline void set_allocated_hash(::std::string* hash);

  // required .fantasybit.BitStake balances = 3;
  inline bool has_balances() const;
  inline void clear_balances();
  static const int kBalancesFieldNumber = 3;
  inline const ::fantasybit::BitStake& balances() const;
  inline ::fantasybit::BitStake* mutable_balances();
  inline ::fantasybit::BitStake* release_balances();
  inline void set_allocated_balances(::fantasybit::BitStake* balances);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:fantasybit.FantasyNameT)
 private:
  inline void set_has_public_key();
  inline void clear_has_public_key();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_balances();
  inline void clear_has_balances();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* public_key_;
  ::std::string* hash_;
  ::fantasybit::BitStake* balances_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static FantasyNameT* default_instance_;
};
// -------------------------------------------------------------------

class BitStake : public ::google::protobuf::Message {
 public:
  BitStake();
  virtual ~BitStake();

  BitStake(const BitStake& from);

  inline BitStake& operator=(const BitStake& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BitStake& default_instance();

  void Swap(BitStake* other);

  // implements Message ----------------------------------------------

  BitStake* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BitStake& from);
  void MergeFrom(const BitStake& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fantasybit.BitStake)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static BitStake* default_instance_;
};
// -------------------------------------------------------------------

class NameTransaction : public ::google::protobuf::Message {
 public:
  NameTransaction();
  virtual ~NameTransaction();

  NameTransaction(const NameTransaction& from);

  inline NameTransaction& operator=(const NameTransaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NameTransaction& default_instance();

  void Swap(NameTransaction* other);

  // implements Message ----------------------------------------------

  NameTransaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameTransaction& from);
  void MergeFrom(const NameTransaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 hash = 1;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 1;
  inline ::google::protobuf::uint64 hash() const;
  inline void set_hash(::google::protobuf::uint64 value);

  // required bytes public_key = 2;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 2;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  inline ::std::string* release_public_key();
  inline void set_allocated_public_key(::std::string* public_key);

  // required uint32 nonce = 3;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 3;
  inline ::google::protobuf::uint32 nonce() const;
  inline void set_nonce(::google::protobuf::uint32 value);

  // required uint32 utc_sec = 4;
  inline bool has_utc_sec() const;
  inline void clear_utc_sec();
  static const int kUtcSecFieldNumber = 4;
  inline ::google::protobuf::uint32 utc_sec() const;
  inline void set_utc_sec(::google::protobuf::uint32 value);

  // required string prev_id = 5;
  inline bool has_prev_id() const;
  inline void clear_prev_id();
  static const int kPrevIdFieldNumber = 5;
  inline const ::std::string& prev_id() const;
  inline void set_prev_id(const ::std::string& value);
  inline void set_prev_id(const char* value);
  inline void set_prev_id(const char* value, size_t size);
  inline ::std::string* mutable_prev_id();
  inline ::std::string* release_prev_id();
  inline void set_allocated_prev_id(::std::string* prev_id);

  // optional bytes sig = 6;
  inline bool has_sig() const;
  inline void clear_sig();
  static const int kSigFieldNumber = 6;
  inline const ::std::string& sig() const;
  inline void set_sig(const ::std::string& value);
  inline void set_sig(const char* value);
  inline void set_sig(const void* value, size_t size);
  inline ::std::string* mutable_sig();
  inline ::std::string* release_sig();
  inline void set_allocated_sig(::std::string* sig);

  // optional string sigid = 7;
  inline bool has_sigid() const;
  inline void clear_sigid();
  static const int kSigidFieldNumber = 7;
  inline const ::std::string& sigid() const;
  inline void set_sigid(const ::std::string& value);
  inline void set_sigid(const char* value);
  inline void set_sigid(const char* value, size_t size);
  inline ::std::string* mutable_sigid();
  inline ::std::string* release_sigid();
  inline void set_allocated_sigid(::std::string* sigid);

  // @@protoc_insertion_point(class_scope:fantasybit.NameTransaction)
 private:
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_public_key();
  inline void clear_has_public_key();
  inline void set_has_nonce();
  inline void clear_has_nonce();
  inline void set_has_utc_sec();
  inline void clear_has_utc_sec();
  inline void set_has_prev_id();
  inline void clear_has_prev_id();
  inline void set_has_sig();
  inline void clear_has_sig();
  inline void set_has_sigid();
  inline void clear_has_sigid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 hash_;
  ::std::string* public_key_;
  ::google::protobuf::uint32 nonce_;
  ::google::protobuf::uint32 utc_sec_;
  ::std::string* prev_id_;
  ::std::string* sig_;
  ::std::string* sigid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static NameTransaction* default_instance_;
};
// -------------------------------------------------------------------

class OutData : public ::google::protobuf::Message {
 public:
  OutData();
  virtual ~OutData();

  OutData(const OutData& from);

  inline OutData& operator=(const OutData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OutData& default_instance();

  void Swap(OutData* other);

  // implements Message ----------------------------------------------

  OutData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OutData& from);
  void MergeFrom(const OutData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef OutData_Type Type;
  static const Type MYFANTASYNAME = OutData_Type_MYFANTASYNAME;
  static const Type SNAPSHOT = OutData_Type_SNAPSHOT;
  static const Type HEARTBEAT = OutData_Type_HEARTBEAT;
  static inline bool Type_IsValid(int value) {
    return OutData_Type_IsValid(value);
  }
  static const Type Type_MIN =
    OutData_Type_Type_MIN;
  static const Type Type_MAX =
    OutData_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    OutData_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return OutData_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return OutData_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return OutData_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .fantasybit.OutData.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::fantasybit::OutData_Type type() const;
  inline void set_type(::fantasybit::OutData_Type value);

  // optional .fantasybit.MyFantasyName myfantasyname = 2;
  inline bool has_myfantasyname() const;
  inline void clear_myfantasyname();
  static const int kMyfantasynameFieldNumber = 2;
  inline const ::fantasybit::MyFantasyName& myfantasyname() const;
  inline ::fantasybit::MyFantasyName* mutable_myfantasyname();
  inline ::fantasybit::MyFantasyName* release_myfantasyname();
  inline void set_allocated_myfantasyname(::fantasybit::MyFantasyName* myfantasyname);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(OutData)
  // @@protoc_insertion_point(class_scope:fantasybit.OutData)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_myfantasyname();
  inline void clear_has_myfantasyname();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::MyFantasyName* myfantasyname_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static OutData* default_instance_;
};
// -------------------------------------------------------------------

class InData : public ::google::protobuf::Message {
 public:
  InData();
  virtual ~InData();

  InData(const InData& from);

  inline InData& operator=(const InData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InData& default_instance();

  void Swap(InData* other);

  // implements Message ----------------------------------------------

  InData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InData& from);
  void MergeFrom(const InData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef InData_Type Type;
  static const Type MINENAME = InData_Type_MINENAME;
  static const Type QUIT = InData_Type_QUIT;
  static const Type HEARTBEAT = InData_Type_HEARTBEAT;
  static const Type CONNECT = InData_Type_CONNECT;
  static const Type MAKE_BLOCK = InData_Type_MAKE_BLOCK;
  static inline bool Type_IsValid(int value) {
    return InData_Type_IsValid(value);
  }
  static const Type Type_MIN =
    InData_Type_Type_MIN;
  static const Type Type_MAX =
    InData_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    InData_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return InData_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return InData_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return InData_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .fantasybit.InData.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::fantasybit::InData_Type type() const;
  inline void set_type(::fantasybit::InData_Type value);

  // optional string data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(InData)
  // @@protoc_insertion_point(class_scope:fantasybit.InData)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* data_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static InData* default_instance_;
};
// -------------------------------------------------------------------

class Transaction : public ::google::protobuf::Message {
 public:
  Transaction();
  virtual ~Transaction();

  Transaction(const Transaction& from);

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Transaction& default_instance();

  void Swap(Transaction* other);

  // implements Message ----------------------------------------------

  Transaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // optional .fantasybit.TransType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::fantasybit::TransType type() const;
  inline void set_type(::fantasybit::TransType value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Transaction)
  // @@protoc_insertion_point(class_scope:fantasybit.Transaction)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 version_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static Transaction* default_instance_;
};
// -------------------------------------------------------------------

class NameTrans : public ::google::protobuf::Message {
 public:
  NameTrans();
  virtual ~NameTrans();

  NameTrans(const NameTrans& from);

  inline NameTrans& operator=(const NameTrans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NameTrans& default_instance();

  void Swap(NameTrans* other);

  // implements Message ----------------------------------------------

  NameTrans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameTrans& from);
  void MergeFrom(const NameTrans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 hash = 1;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 1;
  inline ::google::protobuf::uint64 hash() const;
  inline void set_hash(::google::protobuf::uint64 value);

  // optional bytes public_key = 2;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 2;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  inline ::std::string* release_public_key();
  inline void set_allocated_public_key(::std::string* public_key);

  // optional uint32 nonce = 3;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 3;
  inline ::google::protobuf::uint32 nonce() const;
  inline void set_nonce(::google::protobuf::uint32 value);

  // optional uint32 utc_sec = 4;
  inline bool has_utc_sec() const;
  inline void clear_utc_sec();
  static const int kUtcSecFieldNumber = 4;
  inline ::google::protobuf::uint32 utc_sec() const;
  inline void set_utc_sec(::google::protobuf::uint32 value);

  // optional string prev_id = 5;
  inline bool has_prev_id() const;
  inline void clear_prev_id();
  static const int kPrevIdFieldNumber = 5;
  inline const ::std::string& prev_id() const;
  inline void set_prev_id(const ::std::string& value);
  inline void set_prev_id(const char* value);
  inline void set_prev_id(const char* value, size_t size);
  inline ::std::string* mutable_prev_id();
  inline ::std::string* release_prev_id();
  inline void set_allocated_prev_id(::std::string* prev_id);

  // optional bytes sig = 6;
  inline bool has_sig() const;
  inline void clear_sig();
  static const int kSigFieldNumber = 6;
  inline const ::std::string& sig() const;
  inline void set_sig(const ::std::string& value);
  inline void set_sig(const char* value);
  inline void set_sig(const void* value, size_t size);
  inline ::std::string* mutable_sig();
  inline ::std::string* release_sig();
  inline void set_allocated_sig(::std::string* sig);

  // optional string sigid = 7;
  inline bool has_sigid() const;
  inline void clear_sigid();
  static const int kSigidFieldNumber = 7;
  inline const ::std::string& sigid() const;
  inline void set_sigid(const ::std::string& value);
  inline void set_sigid(const char* value);
  inline void set_sigid(const char* value, size_t size);
  inline ::std::string* mutable_sigid();
  inline ::std::string* release_sigid();
  inline void set_allocated_sigid(::std::string* sigid);

  static const int kNameTransFieldNumber = 200;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::NameTrans >, 11, false >
    name_trans;
  // @@protoc_insertion_point(class_scope:fantasybit.NameTrans)
 private:
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_public_key();
  inline void clear_has_public_key();
  inline void set_has_nonce();
  inline void clear_has_nonce();
  inline void set_has_utc_sec();
  inline void clear_has_utc_sec();
  inline void set_has_prev_id();
  inline void clear_has_prev_id();
  inline void set_has_sig();
  inline void clear_has_sig();
  inline void set_has_sigid();
  inline void clear_has_sigid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 hash_;
  ::std::string* public_key_;
  ::google::protobuf::uint32 nonce_;
  ::google::protobuf::uint32 utc_sec_;
  ::std::string* prev_id_;
  ::std::string* sig_;
  ::std::string* sigid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static NameTrans* default_instance_;
};
// -------------------------------------------------------------------

class FantasyPlayerPoints : public ::google::protobuf::Message {
 public:
  FantasyPlayerPoints();
  virtual ~FantasyPlayerPoints();

  FantasyPlayerPoints(const FantasyPlayerPoints& from);

  inline FantasyPlayerPoints& operator=(const FantasyPlayerPoints& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FantasyPlayerPoints& default_instance();

  void Swap(FantasyPlayerPoints* other);

  // implements Message ----------------------------------------------

  FantasyPlayerPoints* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FantasyPlayerPoints& from);
  void MergeFrom(const FantasyPlayerPoints& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fantasy_player_id = 1;
  inline bool has_fantasy_player_id() const;
  inline void clear_fantasy_player_id();
  static const int kFantasyPlayerIdFieldNumber = 1;
  inline const ::std::string& fantasy_player_id() const;
  inline void set_fantasy_player_id(const ::std::string& value);
  inline void set_fantasy_player_id(const char* value);
  inline void set_fantasy_player_id(const char* value, size_t size);
  inline ::std::string* mutable_fantasy_player_id();
  inline ::std::string* release_fantasy_player_id();
  inline void set_allocated_fantasy_player_id(::std::string* fantasy_player_id);

  // optional int32 points = 2;
  inline bool has_points() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 2;
  inline ::google::protobuf::int32 points() const;
  inline void set_points(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fantasybit.FantasyPlayerPoints)
 private:
  inline void set_has_fantasy_player_id();
  inline void clear_has_fantasy_player_id();
  inline void set_has_points();
  inline void clear_has_points();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fantasy_player_id_;
  ::google::protobuf::int32 points_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static FantasyPlayerPoints* default_instance_;
};
// -------------------------------------------------------------------

class ProjectionTrans : public ::google::protobuf::Message {
 public:
  ProjectionTrans();
  virtual ~ProjectionTrans();

  ProjectionTrans(const ProjectionTrans& from);

  inline ProjectionTrans& operator=(const ProjectionTrans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProjectionTrans& default_instance();

  void Swap(ProjectionTrans* other);

  // implements Message ----------------------------------------------

  ProjectionTrans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProjectionTrans& from);
  void MergeFrom(const ProjectionTrans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string game_id = 2;
  inline bool has_game_id() const;
  inline void clear_game_id();
  static const int kGameIdFieldNumber = 2;
  inline const ::std::string& game_id() const;
  inline void set_game_id(const ::std::string& value);
  inline void set_game_id(const char* value);
  inline void set_game_id(const char* value, size_t size);
  inline ::std::string* mutable_game_id();
  inline ::std::string* release_game_id();
  inline void set_allocated_game_id(::std::string* game_id);

  // optional .fantasybit.FantasyPlayerPoints fpp_projection = 3;
  inline bool has_fpp_projection() const;
  inline void clear_fpp_projection();
  static const int kFppProjectionFieldNumber = 3;
  inline const ::fantasybit::FantasyPlayerPoints& fpp_projection() const;
  inline ::fantasybit::FantasyPlayerPoints* mutable_fpp_projection();
  inline ::fantasybit::FantasyPlayerPoints* release_fpp_projection();
  inline void set_allocated_fpp_projection(::fantasybit::FantasyPlayerPoints* fpp_projection);

  static const int kProjTransFieldNumber = 201;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::ProjectionTrans >, 11, false >
    proj_trans;
  // @@protoc_insertion_point(class_scope:fantasybit.ProjectionTrans)
 private:
  inline void set_has_game_id();
  inline void clear_has_game_id();
  inline void set_has_fpp_projection();
  inline void clear_has_fpp_projection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* game_id_;
  ::fantasybit::FantasyPlayerPoints* fpp_projection_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static ProjectionTrans* default_instance_;
};
// -------------------------------------------------------------------

class ResultTrans : public ::google::protobuf::Message {
 public:
  ResultTrans();
  virtual ~ResultTrans();

  ResultTrans(const ResultTrans& from);

  inline ResultTrans& operator=(const ResultTrans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultTrans& default_instance();

  void Swap(ResultTrans* other);

  // implements Message ----------------------------------------------

  ResultTrans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResultTrans& from);
  void MergeFrom(const ResultTrans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string game_id = 10;
  inline bool has_game_id() const;
  inline void clear_game_id();
  static const int kGameIdFieldNumber = 10;
  inline const ::std::string& game_id() const;
  inline void set_game_id(const ::std::string& value);
  inline void set_game_id(const char* value);
  inline void set_game_id(const char* value, size_t size);
  inline ::std::string* mutable_game_id();
  inline ::std::string* release_game_id();
  inline void set_allocated_game_id(::std::string* game_id);

  // repeated .fantasybit.FantasyPlayerPoints fpp_results = 20;
  inline int fpp_results_size() const;
  inline void clear_fpp_results();
  static const int kFppResultsFieldNumber = 20;
  inline const ::fantasybit::FantasyPlayerPoints& fpp_results(int index) const;
  inline ::fantasybit::FantasyPlayerPoints* mutable_fpp_results(int index);
  inline ::fantasybit::FantasyPlayerPoints* add_fpp_results();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyPlayerPoints >&
      fpp_results() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyPlayerPoints >*
      mutable_fpp_results();

  static const int kResultTransFieldNumber = 202;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::ResultTrans >, 11, false >
    result_trans;
  // @@protoc_insertion_point(class_scope:fantasybit.ResultTrans)
 private:
  inline void set_has_game_id();
  inline void clear_has_game_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* game_id_;
  ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyPlayerPoints > fpp_results_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static ResultTrans* default_instance_;
};
// -------------------------------------------------------------------

class SignedTransaction : public ::google::protobuf::Message {
 public:
  SignedTransaction();
  virtual ~SignedTransaction();

  SignedTransaction(const SignedTransaction& from);

  inline SignedTransaction& operator=(const SignedTransaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignedTransaction& default_instance();

  void Swap(SignedTransaction* other);

  // implements Message ----------------------------------------------

  SignedTransaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignedTransaction& from);
  void MergeFrom(const SignedTransaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .fantasybit.Transaction trans = 10;
  inline bool has_trans() const;
  inline void clear_trans();
  static const int kTransFieldNumber = 10;
  inline const ::fantasybit::Transaction& trans() const;
  inline ::fantasybit::Transaction* mutable_trans();
  inline ::fantasybit::Transaction* release_trans();
  inline void set_allocated_trans(::fantasybit::Transaction* trans);

  // optional bytes id = 20;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 20;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional bytes sig = 30;
  inline bool has_sig() const;
  inline void clear_sig();
  static const int kSigFieldNumber = 30;
  inline const ::std::string& sig() const;
  inline void set_sig(const ::std::string& value);
  inline void set_sig(const char* value);
  inline void set_sig(const void* value, size_t size);
  inline ::std::string* mutable_sig();
  inline ::std::string* release_sig();
  inline void set_allocated_sig(::std::string* sig);

  // optional string fantasy_name = 40;
  inline bool has_fantasy_name() const;
  inline void clear_fantasy_name();
  static const int kFantasyNameFieldNumber = 40;
  inline const ::std::string& fantasy_name() const;
  inline void set_fantasy_name(const ::std::string& value);
  inline void set_fantasy_name(const char* value);
  inline void set_fantasy_name(const char* value, size_t size);
  inline ::std::string* mutable_fantasy_name();
  inline ::std::string* release_fantasy_name();
  inline void set_allocated_fantasy_name(::std::string* fantasy_name);

  // @@protoc_insertion_point(class_scope:fantasybit.SignedTransaction)
 private:
  inline void set_has_trans();
  inline void clear_has_trans();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_sig();
  inline void clear_has_sig();
  inline void set_has_fantasy_name();
  inline void clear_has_fantasy_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::Transaction* trans_;
  ::std::string* id_;
  ::std::string* sig_;
  ::std::string* fantasy_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static SignedTransaction* default_instance_;
};
// -------------------------------------------------------------------

class BlockHeader : public ::google::protobuf::Message {
 public:
  BlockHeader();
  virtual ~BlockHeader();

  BlockHeader(const BlockHeader& from);

  inline BlockHeader& operator=(const BlockHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockHeader& default_instance();

  void Swap(BlockHeader* other);

  // implements Message ----------------------------------------------

  BlockHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlockHeader& from);
  void MergeFrom(const BlockHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 num = 10;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 10;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional bytes prev_id = 20;
  inline bool has_prev_id() const;
  inline void clear_prev_id();
  static const int kPrevIdFieldNumber = 20;
  inline const ::std::string& prev_id() const;
  inline void set_prev_id(const ::std::string& value);
  inline void set_prev_id(const char* value);
  inline void set_prev_id(const void* value, size_t size);
  inline ::std::string* mutable_prev_id();
  inline ::std::string* release_prev_id();
  inline void set_allocated_prev_id(::std::string* prev_id);

  // @@protoc_insertion_point(class_scope:fantasybit.BlockHeader)
 private:
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_prev_id();
  inline void clear_has_prev_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* prev_id_;
  ::google::protobuf::int32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static BlockHeader* default_instance_;
};
// -------------------------------------------------------------------

class Block : public ::google::protobuf::Message {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Block& default_instance();

  void Swap(Block* other);

  // implements Message ----------------------------------------------

  Block* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .fantasybit.BlockHeader head = 10;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 10;
  inline const ::fantasybit::BlockHeader& head() const;
  inline ::fantasybit::BlockHeader* mutable_head();
  inline ::fantasybit::BlockHeader* release_head();
  inline void set_allocated_head(::fantasybit::BlockHeader* head);

  // repeated .fantasybit.SignedTransaction signed_transactions = 20;
  inline int signed_transactions_size() const;
  inline void clear_signed_transactions();
  static const int kSignedTransactionsFieldNumber = 20;
  inline const ::fantasybit::SignedTransaction& signed_transactions(int index) const;
  inline ::fantasybit::SignedTransaction* mutable_signed_transactions(int index);
  inline ::fantasybit::SignedTransaction* add_signed_transactions();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::SignedTransaction >&
      signed_transactions() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::SignedTransaction >*
      mutable_signed_transactions();

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Block)
  // @@protoc_insertion_point(class_scope:fantasybit.Block)
 private:
  inline void set_has_head();
  inline void clear_has_head();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::BlockHeader* head_;
  ::google::protobuf::RepeatedPtrField< ::fantasybit::SignedTransaction > signed_transactions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static Block* default_instance_;
};
// -------------------------------------------------------------------

class SignedBlock : public ::google::protobuf::Message {
 public:
  SignedBlock();
  virtual ~SignedBlock();

  SignedBlock(const SignedBlock& from);

  inline SignedBlock& operator=(const SignedBlock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignedBlock& default_instance();

  void Swap(SignedBlock* other);

  // implements Message ----------------------------------------------

  SignedBlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignedBlock& from);
  void MergeFrom(const SignedBlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // optional .fantasybit.Block block = 10;
  inline bool has_block() const;
  inline void clear_block();
  static const int kBlockFieldNumber = 10;
  inline const ::fantasybit::Block& block() const;
  inline ::fantasybit::Block* mutable_block();
  inline ::fantasybit::Block* release_block();
  inline void set_allocated_block(::fantasybit::Block* block);

  // optional bytes id = 20;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 20;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string sig = 30;
  inline bool has_sig() const;
  inline void clear_sig();
  static const int kSigFieldNumber = 30;
  inline const ::std::string& sig() const;
  inline void set_sig(const ::std::string& value);
  inline void set_sig(const char* value);
  inline void set_sig(const char* value, size_t size);
  inline ::std::string* mutable_sig();
  inline ::std::string* release_sig();
  inline void set_allocated_sig(::std::string* sig);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(SignedBlock)
  // @@protoc_insertion_point(class_scope:fantasybit.SignedBlock)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_block();
  inline void clear_has_block();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_sig();
  inline void clear_has_sig();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::Block* block_;
  ::std::string* id_;
  ::std::string* sig_;
  ::google::protobuf::int32 version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static SignedBlock* default_instance_;
};
// ===================================================================


// ===================================================================

// MyFantasyName

// required string name = 1;
inline bool MyFantasyName::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MyFantasyName::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MyFantasyName::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MyFantasyName::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MyFantasyName::name() const {
  return *name_;
}
inline void MyFantasyName::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MyFantasyName::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MyFantasyName::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MyFantasyName::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MyFantasyName::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MyFantasyName::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .fantasybit.MyNameStatus status = 2;
inline bool MyFantasyName::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MyFantasyName::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MyFantasyName::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MyFantasyName::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::fantasybit::MyNameStatus MyFantasyName::status() const {
  return static_cast< ::fantasybit::MyNameStatus >(status_);
}
inline void MyFantasyName::set_status(::fantasybit::MyNameStatus value) {
  assert(::fantasybit::MyNameStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional .fantasybit.NameTransaction nametransaction = 3;
inline bool MyFantasyName::has_nametransaction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MyFantasyName::set_has_nametransaction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MyFantasyName::clear_has_nametransaction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MyFantasyName::clear_nametransaction() {
  if (nametransaction_ != NULL) nametransaction_->::fantasybit::NameTransaction::Clear();
  clear_has_nametransaction();
}
inline const ::fantasybit::NameTransaction& MyFantasyName::nametransaction() const {
  return nametransaction_ != NULL ? *nametransaction_ : *default_instance_->nametransaction_;
}
inline ::fantasybit::NameTransaction* MyFantasyName::mutable_nametransaction() {
  set_has_nametransaction();
  if (nametransaction_ == NULL) nametransaction_ = new ::fantasybit::NameTransaction;
  return nametransaction_;
}
inline ::fantasybit::NameTransaction* MyFantasyName::release_nametransaction() {
  clear_has_nametransaction();
  ::fantasybit::NameTransaction* temp = nametransaction_;
  nametransaction_ = NULL;
  return temp;
}
inline void MyFantasyName::set_allocated_nametransaction(::fantasybit::NameTransaction* nametransaction) {
  delete nametransaction_;
  nametransaction_ = nametransaction;
  if (nametransaction) {
    set_has_nametransaction();
  } else {
    clear_has_nametransaction();
  }
}

// -------------------------------------------------------------------

// Secret

// required string private_key = 1;
inline bool Secret::has_private_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Secret::set_has_private_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Secret::clear_has_private_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Secret::clear_private_key() {
  if (private_key_ != &::google::protobuf::internal::kEmptyString) {
    private_key_->clear();
  }
  clear_has_private_key();
}
inline const ::std::string& Secret::private_key() const {
  return *private_key_;
}
inline void Secret::set_private_key(const ::std::string& value) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void Secret::set_private_key(const char* value) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void Secret::set_private_key(const char* value, size_t size) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Secret::mutable_private_key() {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  return private_key_;
}
inline ::std::string* Secret::release_private_key() {
  clear_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = private_key_;
    private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Secret::set_allocated_private_key(::std::string* private_key) {
  if (private_key_ != &::google::protobuf::internal::kEmptyString) {
    delete private_key_;
  }
  if (private_key) {
    set_has_private_key();
    private_key_ = private_key;
  } else {
    clear_has_private_key();
    private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .fantasybit.MyFantasyName myfantasyname = 2;
inline bool Secret::has_myfantasyname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Secret::set_has_myfantasyname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Secret::clear_has_myfantasyname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Secret::clear_myfantasyname() {
  if (myfantasyname_ != NULL) myfantasyname_->::fantasybit::MyFantasyName::Clear();
  clear_has_myfantasyname();
}
inline const ::fantasybit::MyFantasyName& Secret::myfantasyname() const {
  return myfantasyname_ != NULL ? *myfantasyname_ : *default_instance_->myfantasyname_;
}
inline ::fantasybit::MyFantasyName* Secret::mutable_myfantasyname() {
  set_has_myfantasyname();
  if (myfantasyname_ == NULL) myfantasyname_ = new ::fantasybit::MyFantasyName;
  return myfantasyname_;
}
inline ::fantasybit::MyFantasyName* Secret::release_myfantasyname() {
  clear_has_myfantasyname();
  ::fantasybit::MyFantasyName* temp = myfantasyname_;
  myfantasyname_ = NULL;
  return temp;
}
inline void Secret::set_allocated_myfantasyname(::fantasybit::MyFantasyName* myfantasyname) {
  delete myfantasyname_;
  myfantasyname_ = myfantasyname;
  if (myfantasyname) {
    set_has_myfantasyname();
  } else {
    clear_has_myfantasyname();
  }
}

// -------------------------------------------------------------------

// FantasyNameT

// required string public_key = 1;
inline bool FantasyNameT::has_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FantasyNameT::set_has_public_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FantasyNameT::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FantasyNameT::clear_public_key() {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    public_key_->clear();
  }
  clear_has_public_key();
}
inline const ::std::string& FantasyNameT::public_key() const {
  return *public_key_;
}
inline void FantasyNameT::set_public_key(const ::std::string& value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void FantasyNameT::set_public_key(const char* value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void FantasyNameT::set_public_key(const char* value, size_t size) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameT::mutable_public_key() {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}
inline ::std::string* FantasyNameT::release_public_key() {
  clear_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_key_;
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameT::set_allocated_public_key(::std::string* public_key) {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    delete public_key_;
  }
  if (public_key) {
    set_has_public_key();
    public_key_ = public_key;
  } else {
    clear_has_public_key();
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string hash = 2;
inline bool FantasyNameT::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FantasyNameT::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FantasyNameT::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FantasyNameT::clear_hash() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& FantasyNameT::hash() const {
  return *hash_;
}
inline void FantasyNameT::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void FantasyNameT::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void FantasyNameT::set_hash(const char* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameT::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  return hash_;
}
inline ::std::string* FantasyNameT::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameT::set_allocated_hash(::std::string* hash) {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    delete hash_;
  }
  if (hash) {
    set_has_hash();
    hash_ = hash;
  } else {
    clear_has_hash();
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .fantasybit.BitStake balances = 3;
inline bool FantasyNameT::has_balances() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FantasyNameT::set_has_balances() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FantasyNameT::clear_has_balances() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FantasyNameT::clear_balances() {
  if (balances_ != NULL) balances_->::fantasybit::BitStake::Clear();
  clear_has_balances();
}
inline const ::fantasybit::BitStake& FantasyNameT::balances() const {
  return balances_ != NULL ? *balances_ : *default_instance_->balances_;
}
inline ::fantasybit::BitStake* FantasyNameT::mutable_balances() {
  set_has_balances();
  if (balances_ == NULL) balances_ = new ::fantasybit::BitStake;
  return balances_;
}
inline ::fantasybit::BitStake* FantasyNameT::release_balances() {
  clear_has_balances();
  ::fantasybit::BitStake* temp = balances_;
  balances_ = NULL;
  return temp;
}
inline void FantasyNameT::set_allocated_balances(::fantasybit::BitStake* balances) {
  delete balances_;
  balances_ = balances;
  if (balances) {
    set_has_balances();
  } else {
    clear_has_balances();
  }
}

// optional string name = 4;
inline bool FantasyNameT::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FantasyNameT::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FantasyNameT::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FantasyNameT::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FantasyNameT::name() const {
  return *name_;
}
inline void FantasyNameT::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FantasyNameT::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FantasyNameT::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameT::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FantasyNameT::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameT::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BitStake

// -------------------------------------------------------------------

// NameTransaction

// required uint64 hash = 1;
inline bool NameTransaction::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameTransaction::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameTransaction::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameTransaction::clear_hash() {
  hash_ = GOOGLE_ULONGLONG(0);
  clear_has_hash();
}
inline ::google::protobuf::uint64 NameTransaction::hash() const {
  return hash_;
}
inline void NameTransaction::set_hash(::google::protobuf::uint64 value) {
  set_has_hash();
  hash_ = value;
}

// required bytes public_key = 2;
inline bool NameTransaction::has_public_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameTransaction::set_has_public_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameTransaction::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameTransaction::clear_public_key() {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    public_key_->clear();
  }
  clear_has_public_key();
}
inline const ::std::string& NameTransaction::public_key() const {
  return *public_key_;
}
inline void NameTransaction::set_public_key(const ::std::string& value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void NameTransaction::set_public_key(const char* value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void NameTransaction::set_public_key(const void* value, size_t size) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameTransaction::mutable_public_key() {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}
inline ::std::string* NameTransaction::release_public_key() {
  clear_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_key_;
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameTransaction::set_allocated_public_key(::std::string* public_key) {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    delete public_key_;
  }
  if (public_key) {
    set_has_public_key();
    public_key_ = public_key;
  } else {
    clear_has_public_key();
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 nonce = 3;
inline bool NameTransaction::has_nonce() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NameTransaction::set_has_nonce() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NameTransaction::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NameTransaction::clear_nonce() {
  nonce_ = 0u;
  clear_has_nonce();
}
inline ::google::protobuf::uint32 NameTransaction::nonce() const {
  return nonce_;
}
inline void NameTransaction::set_nonce(::google::protobuf::uint32 value) {
  set_has_nonce();
  nonce_ = value;
}

// required uint32 utc_sec = 4;
inline bool NameTransaction::has_utc_sec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NameTransaction::set_has_utc_sec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NameTransaction::clear_has_utc_sec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NameTransaction::clear_utc_sec() {
  utc_sec_ = 0u;
  clear_has_utc_sec();
}
inline ::google::protobuf::uint32 NameTransaction::utc_sec() const {
  return utc_sec_;
}
inline void NameTransaction::set_utc_sec(::google::protobuf::uint32 value) {
  set_has_utc_sec();
  utc_sec_ = value;
}

// required string prev_id = 5;
inline bool NameTransaction::has_prev_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NameTransaction::set_has_prev_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NameTransaction::clear_has_prev_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NameTransaction::clear_prev_id() {
  if (prev_id_ != &::google::protobuf::internal::kEmptyString) {
    prev_id_->clear();
  }
  clear_has_prev_id();
}
inline const ::std::string& NameTransaction::prev_id() const {
  return *prev_id_;
}
inline void NameTransaction::set_prev_id(const ::std::string& value) {
  set_has_prev_id();
  if (prev_id_ == &::google::protobuf::internal::kEmptyString) {
    prev_id_ = new ::std::string;
  }
  prev_id_->assign(value);
}
inline void NameTransaction::set_prev_id(const char* value) {
  set_has_prev_id();
  if (prev_id_ == &::google::protobuf::internal::kEmptyString) {
    prev_id_ = new ::std::string;
  }
  prev_id_->assign(value);
}
inline void NameTransaction::set_prev_id(const char* value, size_t size) {
  set_has_prev_id();
  if (prev_id_ == &::google::protobuf::internal::kEmptyString) {
    prev_id_ = new ::std::string;
  }
  prev_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameTransaction::mutable_prev_id() {
  set_has_prev_id();
  if (prev_id_ == &::google::protobuf::internal::kEmptyString) {
    prev_id_ = new ::std::string;
  }
  return prev_id_;
}
inline ::std::string* NameTransaction::release_prev_id() {
  clear_has_prev_id();
  if (prev_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_id_;
    prev_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameTransaction::set_allocated_prev_id(::std::string* prev_id) {
  if (prev_id_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_id_;
  }
  if (prev_id) {
    set_has_prev_id();
    prev_id_ = prev_id;
  } else {
    clear_has_prev_id();
    prev_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes sig = 6;
inline bool NameTransaction::has_sig() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NameTransaction::set_has_sig() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NameTransaction::clear_has_sig() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NameTransaction::clear_sig() {
  if (sig_ != &::google::protobuf::internal::kEmptyString) {
    sig_->clear();
  }
  clear_has_sig();
}
inline const ::std::string& NameTransaction::sig() const {
  return *sig_;
}
inline void NameTransaction::set_sig(const ::std::string& value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void NameTransaction::set_sig(const char* value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void NameTransaction::set_sig(const void* value, size_t size) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameTransaction::mutable_sig() {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  return sig_;
}
inline ::std::string* NameTransaction::release_sig() {
  clear_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sig_;
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameTransaction::set_allocated_sig(::std::string* sig) {
  if (sig_ != &::google::protobuf::internal::kEmptyString) {
    delete sig_;
  }
  if (sig) {
    set_has_sig();
    sig_ = sig;
  } else {
    clear_has_sig();
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sigid = 7;
inline bool NameTransaction::has_sigid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NameTransaction::set_has_sigid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NameTransaction::clear_has_sigid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NameTransaction::clear_sigid() {
  if (sigid_ != &::google::protobuf::internal::kEmptyString) {
    sigid_->clear();
  }
  clear_has_sigid();
}
inline const ::std::string& NameTransaction::sigid() const {
  return *sigid_;
}
inline void NameTransaction::set_sigid(const ::std::string& value) {
  set_has_sigid();
  if (sigid_ == &::google::protobuf::internal::kEmptyString) {
    sigid_ = new ::std::string;
  }
  sigid_->assign(value);
}
inline void NameTransaction::set_sigid(const char* value) {
  set_has_sigid();
  if (sigid_ == &::google::protobuf::internal::kEmptyString) {
    sigid_ = new ::std::string;
  }
  sigid_->assign(value);
}
inline void NameTransaction::set_sigid(const char* value, size_t size) {
  set_has_sigid();
  if (sigid_ == &::google::protobuf::internal::kEmptyString) {
    sigid_ = new ::std::string;
  }
  sigid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameTransaction::mutable_sigid() {
  set_has_sigid();
  if (sigid_ == &::google::protobuf::internal::kEmptyString) {
    sigid_ = new ::std::string;
  }
  return sigid_;
}
inline ::std::string* NameTransaction::release_sigid() {
  clear_has_sigid();
  if (sigid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sigid_;
    sigid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameTransaction::set_allocated_sigid(::std::string* sigid) {
  if (sigid_ != &::google::protobuf::internal::kEmptyString) {
    delete sigid_;
  }
  if (sigid) {
    set_has_sigid();
    sigid_ = sigid;
  } else {
    clear_has_sigid();
    sigid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OutData

// required .fantasybit.OutData.Type type = 1;
inline bool OutData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OutData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OutData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OutData::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::fantasybit::OutData_Type OutData::type() const {
  return static_cast< ::fantasybit::OutData_Type >(type_);
}
inline void OutData::set_type(::fantasybit::OutData_Type value) {
  assert(::fantasybit::OutData_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .fantasybit.MyFantasyName myfantasyname = 2;
inline bool OutData::has_myfantasyname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OutData::set_has_myfantasyname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OutData::clear_has_myfantasyname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OutData::clear_myfantasyname() {
  if (myfantasyname_ != NULL) myfantasyname_->::fantasybit::MyFantasyName::Clear();
  clear_has_myfantasyname();
}
inline const ::fantasybit::MyFantasyName& OutData::myfantasyname() const {
  return myfantasyname_ != NULL ? *myfantasyname_ : *default_instance_->myfantasyname_;
}
inline ::fantasybit::MyFantasyName* OutData::mutable_myfantasyname() {
  set_has_myfantasyname();
  if (myfantasyname_ == NULL) myfantasyname_ = new ::fantasybit::MyFantasyName;
  return myfantasyname_;
}
inline ::fantasybit::MyFantasyName* OutData::release_myfantasyname() {
  clear_has_myfantasyname();
  ::fantasybit::MyFantasyName* temp = myfantasyname_;
  myfantasyname_ = NULL;
  return temp;
}
inline void OutData::set_allocated_myfantasyname(::fantasybit::MyFantasyName* myfantasyname) {
  delete myfantasyname_;
  myfantasyname_ = myfantasyname;
  if (myfantasyname) {
    set_has_myfantasyname();
  } else {
    clear_has_myfantasyname();
  }
}

// -------------------------------------------------------------------

// InData

// required .fantasybit.InData.Type type = 1;
inline bool InData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InData::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::fantasybit::InData_Type InData::type() const {
  return static_cast< ::fantasybit::InData_Type >(type_);
}
inline void InData::set_type(::fantasybit::InData_Type value) {
  assert(::fantasybit::InData_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string data = 2;
inline bool InData::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InData::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InData::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InData::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& InData::data() const {
  return *data_;
}
inline void InData::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void InData::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void InData::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InData::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* InData::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InData::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Transaction

// optional int32 version = 1;
inline bool Transaction::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Transaction::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Transaction::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Transaction::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 Transaction::version() const {
  return version_;
}
inline void Transaction::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// optional .fantasybit.TransType type = 2;
inline bool Transaction::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Transaction::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Transaction::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Transaction::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::fantasybit::TransType Transaction::type() const {
  return static_cast< ::fantasybit::TransType >(type_);
}
inline void Transaction::set_type(::fantasybit::TransType value) {
  assert(::fantasybit::TransType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// NameTrans

// optional uint64 hash = 1;
inline bool NameTrans::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameTrans::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameTrans::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameTrans::clear_hash() {
  hash_ = GOOGLE_ULONGLONG(0);
  clear_has_hash();
}
inline ::google::protobuf::uint64 NameTrans::hash() const {
  return hash_;
}
inline void NameTrans::set_hash(::google::protobuf::uint64 value) {
  set_has_hash();
  hash_ = value;
}

// optional bytes public_key = 2;
inline bool NameTrans::has_public_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameTrans::set_has_public_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameTrans::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameTrans::clear_public_key() {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    public_key_->clear();
  }
  clear_has_public_key();
}
inline const ::std::string& NameTrans::public_key() const {
  return *public_key_;
}
inline void NameTrans::set_public_key(const ::std::string& value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void NameTrans::set_public_key(const char* value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void NameTrans::set_public_key(const void* value, size_t size) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameTrans::mutable_public_key() {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}
inline ::std::string* NameTrans::release_public_key() {
  clear_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_key_;
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameTrans::set_allocated_public_key(::std::string* public_key) {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    delete public_key_;
  }
  if (public_key) {
    set_has_public_key();
    public_key_ = public_key;
  } else {
    clear_has_public_key();
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 nonce = 3;
inline bool NameTrans::has_nonce() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NameTrans::set_has_nonce() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NameTrans::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NameTrans::clear_nonce() {
  nonce_ = 0u;
  clear_has_nonce();
}
inline ::google::protobuf::uint32 NameTrans::nonce() const {
  return nonce_;
}
inline void NameTrans::set_nonce(::google::protobuf::uint32 value) {
  set_has_nonce();
  nonce_ = value;
}

// optional uint32 utc_sec = 4;
inline bool NameTrans::has_utc_sec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NameTrans::set_has_utc_sec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NameTrans::clear_has_utc_sec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NameTrans::clear_utc_sec() {
  utc_sec_ = 0u;
  clear_has_utc_sec();
}
inline ::google::protobuf::uint32 NameTrans::utc_sec() const {
  return utc_sec_;
}
inline void NameTrans::set_utc_sec(::google::protobuf::uint32 value) {
  set_has_utc_sec();
  utc_sec_ = value;
}

// optional string prev_id = 5;
inline bool NameTrans::has_prev_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NameTrans::set_has_prev_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NameTrans::clear_has_prev_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NameTrans::clear_prev_id() {
  if (prev_id_ != &::google::protobuf::internal::kEmptyString) {
    prev_id_->clear();
  }
  clear_has_prev_id();
}
inline const ::std::string& NameTrans::prev_id() const {
  return *prev_id_;
}
inline void NameTrans::set_prev_id(const ::std::string& value) {
  set_has_prev_id();
  if (prev_id_ == &::google::protobuf::internal::kEmptyString) {
    prev_id_ = new ::std::string;
  }
  prev_id_->assign(value);
}
inline void NameTrans::set_prev_id(const char* value) {
  set_has_prev_id();
  if (prev_id_ == &::google::protobuf::internal::kEmptyString) {
    prev_id_ = new ::std::string;
  }
  prev_id_->assign(value);
}
inline void NameTrans::set_prev_id(const char* value, size_t size) {
  set_has_prev_id();
  if (prev_id_ == &::google::protobuf::internal::kEmptyString) {
    prev_id_ = new ::std::string;
  }
  prev_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameTrans::mutable_prev_id() {
  set_has_prev_id();
  if (prev_id_ == &::google::protobuf::internal::kEmptyString) {
    prev_id_ = new ::std::string;
  }
  return prev_id_;
}
inline ::std::string* NameTrans::release_prev_id() {
  clear_has_prev_id();
  if (prev_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_id_;
    prev_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameTrans::set_allocated_prev_id(::std::string* prev_id) {
  if (prev_id_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_id_;
  }
  if (prev_id) {
    set_has_prev_id();
    prev_id_ = prev_id;
  } else {
    clear_has_prev_id();
    prev_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes sig = 6;
inline bool NameTrans::has_sig() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NameTrans::set_has_sig() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NameTrans::clear_has_sig() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NameTrans::clear_sig() {
  if (sig_ != &::google::protobuf::internal::kEmptyString) {
    sig_->clear();
  }
  clear_has_sig();
}
inline const ::std::string& NameTrans::sig() const {
  return *sig_;
}
inline void NameTrans::set_sig(const ::std::string& value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void NameTrans::set_sig(const char* value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void NameTrans::set_sig(const void* value, size_t size) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameTrans::mutable_sig() {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  return sig_;
}
inline ::std::string* NameTrans::release_sig() {
  clear_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sig_;
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameTrans::set_allocated_sig(::std::string* sig) {
  if (sig_ != &::google::protobuf::internal::kEmptyString) {
    delete sig_;
  }
  if (sig) {
    set_has_sig();
    sig_ = sig;
  } else {
    clear_has_sig();
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sigid = 7;
inline bool NameTrans::has_sigid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NameTrans::set_has_sigid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NameTrans::clear_has_sigid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NameTrans::clear_sigid() {
  if (sigid_ != &::google::protobuf::internal::kEmptyString) {
    sigid_->clear();
  }
  clear_has_sigid();
}
inline const ::std::string& NameTrans::sigid() const {
  return *sigid_;
}
inline void NameTrans::set_sigid(const ::std::string& value) {
  set_has_sigid();
  if (sigid_ == &::google::protobuf::internal::kEmptyString) {
    sigid_ = new ::std::string;
  }
  sigid_->assign(value);
}
inline void NameTrans::set_sigid(const char* value) {
  set_has_sigid();
  if (sigid_ == &::google::protobuf::internal::kEmptyString) {
    sigid_ = new ::std::string;
  }
  sigid_->assign(value);
}
inline void NameTrans::set_sigid(const char* value, size_t size) {
  set_has_sigid();
  if (sigid_ == &::google::protobuf::internal::kEmptyString) {
    sigid_ = new ::std::string;
  }
  sigid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameTrans::mutable_sigid() {
  set_has_sigid();
  if (sigid_ == &::google::protobuf::internal::kEmptyString) {
    sigid_ = new ::std::string;
  }
  return sigid_;
}
inline ::std::string* NameTrans::release_sigid() {
  clear_has_sigid();
  if (sigid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sigid_;
    sigid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameTrans::set_allocated_sigid(::std::string* sigid) {
  if (sigid_ != &::google::protobuf::internal::kEmptyString) {
    delete sigid_;
  }
  if (sigid) {
    set_has_sigid();
    sigid_ = sigid;
  } else {
    clear_has_sigid();
    sigid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FantasyPlayerPoints

// optional string fantasy_player_id = 1;
inline bool FantasyPlayerPoints::has_fantasy_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FantasyPlayerPoints::set_has_fantasy_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FantasyPlayerPoints::clear_has_fantasy_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FantasyPlayerPoints::clear_fantasy_player_id() {
  if (fantasy_player_id_ != &::google::protobuf::internal::kEmptyString) {
    fantasy_player_id_->clear();
  }
  clear_has_fantasy_player_id();
}
inline const ::std::string& FantasyPlayerPoints::fantasy_player_id() const {
  return *fantasy_player_id_;
}
inline void FantasyPlayerPoints::set_fantasy_player_id(const ::std::string& value) {
  set_has_fantasy_player_id();
  if (fantasy_player_id_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_player_id_ = new ::std::string;
  }
  fantasy_player_id_->assign(value);
}
inline void FantasyPlayerPoints::set_fantasy_player_id(const char* value) {
  set_has_fantasy_player_id();
  if (fantasy_player_id_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_player_id_ = new ::std::string;
  }
  fantasy_player_id_->assign(value);
}
inline void FantasyPlayerPoints::set_fantasy_player_id(const char* value, size_t size) {
  set_has_fantasy_player_id();
  if (fantasy_player_id_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_player_id_ = new ::std::string;
  }
  fantasy_player_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyPlayerPoints::mutable_fantasy_player_id() {
  set_has_fantasy_player_id();
  if (fantasy_player_id_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_player_id_ = new ::std::string;
  }
  return fantasy_player_id_;
}
inline ::std::string* FantasyPlayerPoints::release_fantasy_player_id() {
  clear_has_fantasy_player_id();
  if (fantasy_player_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fantasy_player_id_;
    fantasy_player_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyPlayerPoints::set_allocated_fantasy_player_id(::std::string* fantasy_player_id) {
  if (fantasy_player_id_ != &::google::protobuf::internal::kEmptyString) {
    delete fantasy_player_id_;
  }
  if (fantasy_player_id) {
    set_has_fantasy_player_id();
    fantasy_player_id_ = fantasy_player_id;
  } else {
    clear_has_fantasy_player_id();
    fantasy_player_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 points = 2;
inline bool FantasyPlayerPoints::has_points() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FantasyPlayerPoints::set_has_points() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FantasyPlayerPoints::clear_has_points() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FantasyPlayerPoints::clear_points() {
  points_ = 0;
  clear_has_points();
}
inline ::google::protobuf::int32 FantasyPlayerPoints::points() const {
  return points_;
}
inline void FantasyPlayerPoints::set_points(::google::protobuf::int32 value) {
  set_has_points();
  points_ = value;
}

// -------------------------------------------------------------------

// ProjectionTrans

// optional string game_id = 2;
inline bool ProjectionTrans::has_game_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProjectionTrans::set_has_game_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProjectionTrans::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProjectionTrans::clear_game_id() {
  if (game_id_ != &::google::protobuf::internal::kEmptyString) {
    game_id_->clear();
  }
  clear_has_game_id();
}
inline const ::std::string& ProjectionTrans::game_id() const {
  return *game_id_;
}
inline void ProjectionTrans::set_game_id(const ::std::string& value) {
  set_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    game_id_ = new ::std::string;
  }
  game_id_->assign(value);
}
inline void ProjectionTrans::set_game_id(const char* value) {
  set_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    game_id_ = new ::std::string;
  }
  game_id_->assign(value);
}
inline void ProjectionTrans::set_game_id(const char* value, size_t size) {
  set_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    game_id_ = new ::std::string;
  }
  game_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProjectionTrans::mutable_game_id() {
  set_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    game_id_ = new ::std::string;
  }
  return game_id_;
}
inline ::std::string* ProjectionTrans::release_game_id() {
  clear_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = game_id_;
    game_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProjectionTrans::set_allocated_game_id(::std::string* game_id) {
  if (game_id_ != &::google::protobuf::internal::kEmptyString) {
    delete game_id_;
  }
  if (game_id) {
    set_has_game_id();
    game_id_ = game_id;
  } else {
    clear_has_game_id();
    game_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .fantasybit.FantasyPlayerPoints fpp_projection = 3;
inline bool ProjectionTrans::has_fpp_projection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProjectionTrans::set_has_fpp_projection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProjectionTrans::clear_has_fpp_projection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProjectionTrans::clear_fpp_projection() {
  if (fpp_projection_ != NULL) fpp_projection_->::fantasybit::FantasyPlayerPoints::Clear();
  clear_has_fpp_projection();
}
inline const ::fantasybit::FantasyPlayerPoints& ProjectionTrans::fpp_projection() const {
  return fpp_projection_ != NULL ? *fpp_projection_ : *default_instance_->fpp_projection_;
}
inline ::fantasybit::FantasyPlayerPoints* ProjectionTrans::mutable_fpp_projection() {
  set_has_fpp_projection();
  if (fpp_projection_ == NULL) fpp_projection_ = new ::fantasybit::FantasyPlayerPoints;
  return fpp_projection_;
}
inline ::fantasybit::FantasyPlayerPoints* ProjectionTrans::release_fpp_projection() {
  clear_has_fpp_projection();
  ::fantasybit::FantasyPlayerPoints* temp = fpp_projection_;
  fpp_projection_ = NULL;
  return temp;
}
inline void ProjectionTrans::set_allocated_fpp_projection(::fantasybit::FantasyPlayerPoints* fpp_projection) {
  delete fpp_projection_;
  fpp_projection_ = fpp_projection;
  if (fpp_projection) {
    set_has_fpp_projection();
  } else {
    clear_has_fpp_projection();
  }
}

// -------------------------------------------------------------------

// ResultTrans

// optional string game_id = 10;
inline bool ResultTrans::has_game_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResultTrans::set_has_game_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResultTrans::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResultTrans::clear_game_id() {
  if (game_id_ != &::google::protobuf::internal::kEmptyString) {
    game_id_->clear();
  }
  clear_has_game_id();
}
inline const ::std::string& ResultTrans::game_id() const {
  return *game_id_;
}
inline void ResultTrans::set_game_id(const ::std::string& value) {
  set_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    game_id_ = new ::std::string;
  }
  game_id_->assign(value);
}
inline void ResultTrans::set_game_id(const char* value) {
  set_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    game_id_ = new ::std::string;
  }
  game_id_->assign(value);
}
inline void ResultTrans::set_game_id(const char* value, size_t size) {
  set_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    game_id_ = new ::std::string;
  }
  game_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResultTrans::mutable_game_id() {
  set_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    game_id_ = new ::std::string;
  }
  return game_id_;
}
inline ::std::string* ResultTrans::release_game_id() {
  clear_has_game_id();
  if (game_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = game_id_;
    game_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResultTrans::set_allocated_game_id(::std::string* game_id) {
  if (game_id_ != &::google::protobuf::internal::kEmptyString) {
    delete game_id_;
  }
  if (game_id) {
    set_has_game_id();
    game_id_ = game_id;
  } else {
    clear_has_game_id();
    game_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .fantasybit.FantasyPlayerPoints fpp_results = 20;
inline int ResultTrans::fpp_results_size() const {
  return fpp_results_.size();
}
inline void ResultTrans::clear_fpp_results() {
  fpp_results_.Clear();
}
inline const ::fantasybit::FantasyPlayerPoints& ResultTrans::fpp_results(int index) const {
  return fpp_results_.Get(index);
}
inline ::fantasybit::FantasyPlayerPoints* ResultTrans::mutable_fpp_results(int index) {
  return fpp_results_.Mutable(index);
}
inline ::fantasybit::FantasyPlayerPoints* ResultTrans::add_fpp_results() {
  return fpp_results_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyPlayerPoints >&
ResultTrans::fpp_results() const {
  return fpp_results_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyPlayerPoints >*
ResultTrans::mutable_fpp_results() {
  return &fpp_results_;
}

// -------------------------------------------------------------------

// SignedTransaction

// optional .fantasybit.Transaction trans = 10;
inline bool SignedTransaction::has_trans() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignedTransaction::set_has_trans() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignedTransaction::clear_has_trans() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignedTransaction::clear_trans() {
  if (trans_ != NULL) trans_->::fantasybit::Transaction::Clear();
  clear_has_trans();
}
inline const ::fantasybit::Transaction& SignedTransaction::trans() const {
  return trans_ != NULL ? *trans_ : *default_instance_->trans_;
}
inline ::fantasybit::Transaction* SignedTransaction::mutable_trans() {
  set_has_trans();
  if (trans_ == NULL) trans_ = new ::fantasybit::Transaction;
  return trans_;
}
inline ::fantasybit::Transaction* SignedTransaction::release_trans() {
  clear_has_trans();
  ::fantasybit::Transaction* temp = trans_;
  trans_ = NULL;
  return temp;
}
inline void SignedTransaction::set_allocated_trans(::fantasybit::Transaction* trans) {
  delete trans_;
  trans_ = trans;
  if (trans) {
    set_has_trans();
  } else {
    clear_has_trans();
  }
}

// optional bytes id = 20;
inline bool SignedTransaction::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignedTransaction::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignedTransaction::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignedTransaction::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& SignedTransaction::id() const {
  return *id_;
}
inline void SignedTransaction::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SignedTransaction::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SignedTransaction::set_id(const void* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedTransaction::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* SignedTransaction::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedTransaction::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes sig = 30;
inline bool SignedTransaction::has_sig() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignedTransaction::set_has_sig() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignedTransaction::clear_has_sig() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignedTransaction::clear_sig() {
  if (sig_ != &::google::protobuf::internal::kEmptyString) {
    sig_->clear();
  }
  clear_has_sig();
}
inline const ::std::string& SignedTransaction::sig() const {
  return *sig_;
}
inline void SignedTransaction::set_sig(const ::std::string& value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void SignedTransaction::set_sig(const char* value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void SignedTransaction::set_sig(const void* value, size_t size) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedTransaction::mutable_sig() {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  return sig_;
}
inline ::std::string* SignedTransaction::release_sig() {
  clear_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sig_;
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedTransaction::set_allocated_sig(::std::string* sig) {
  if (sig_ != &::google::protobuf::internal::kEmptyString) {
    delete sig_;
  }
  if (sig) {
    set_has_sig();
    sig_ = sig;
  } else {
    clear_has_sig();
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fantasy_name = 40;
inline bool SignedTransaction::has_fantasy_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignedTransaction::set_has_fantasy_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignedTransaction::clear_has_fantasy_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignedTransaction::clear_fantasy_name() {
  if (fantasy_name_ != &::google::protobuf::internal::kEmptyString) {
    fantasy_name_->clear();
  }
  clear_has_fantasy_name();
}
inline const ::std::string& SignedTransaction::fantasy_name() const {
  return *fantasy_name_;
}
inline void SignedTransaction::set_fantasy_name(const ::std::string& value) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(value);
}
inline void SignedTransaction::set_fantasy_name(const char* value) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(value);
}
inline void SignedTransaction::set_fantasy_name(const char* value, size_t size) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedTransaction::mutable_fantasy_name() {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  return fantasy_name_;
}
inline ::std::string* SignedTransaction::release_fantasy_name() {
  clear_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fantasy_name_;
    fantasy_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedTransaction::set_allocated_fantasy_name(::std::string* fantasy_name) {
  if (fantasy_name_ != &::google::protobuf::internal::kEmptyString) {
    delete fantasy_name_;
  }
  if (fantasy_name) {
    set_has_fantasy_name();
    fantasy_name_ = fantasy_name;
  } else {
    clear_has_fantasy_name();
    fantasy_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BlockHeader

// optional int32 num = 10;
inline bool BlockHeader::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockHeader::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockHeader::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockHeader::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 BlockHeader::num() const {
  return num_;
}
inline void BlockHeader::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional bytes prev_id = 20;
inline bool BlockHeader::has_prev_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlockHeader::set_has_prev_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlockHeader::clear_has_prev_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlockHeader::clear_prev_id() {
  if (prev_id_ != &::google::protobuf::internal::kEmptyString) {
    prev_id_->clear();
  }
  clear_has_prev_id();
}
inline const ::std::string& BlockHeader::prev_id() const {
  return *prev_id_;
}
inline void BlockHeader::set_prev_id(const ::std::string& value) {
  set_has_prev_id();
  if (prev_id_ == &::google::protobuf::internal::kEmptyString) {
    prev_id_ = new ::std::string;
  }
  prev_id_->assign(value);
}
inline void BlockHeader::set_prev_id(const char* value) {
  set_has_prev_id();
  if (prev_id_ == &::google::protobuf::internal::kEmptyString) {
    prev_id_ = new ::std::string;
  }
  prev_id_->assign(value);
}
inline void BlockHeader::set_prev_id(const void* value, size_t size) {
  set_has_prev_id();
  if (prev_id_ == &::google::protobuf::internal::kEmptyString) {
    prev_id_ = new ::std::string;
  }
  prev_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlockHeader::mutable_prev_id() {
  set_has_prev_id();
  if (prev_id_ == &::google::protobuf::internal::kEmptyString) {
    prev_id_ = new ::std::string;
  }
  return prev_id_;
}
inline ::std::string* BlockHeader::release_prev_id() {
  clear_has_prev_id();
  if (prev_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_id_;
    prev_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlockHeader::set_allocated_prev_id(::std::string* prev_id) {
  if (prev_id_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_id_;
  }
  if (prev_id) {
    set_has_prev_id();
    prev_id_ = prev_id;
  } else {
    clear_has_prev_id();
    prev_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Block

// optional .fantasybit.BlockHeader head = 10;
inline bool Block::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Block::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Block::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Block::clear_head() {
  if (head_ != NULL) head_->::fantasybit::BlockHeader::Clear();
  clear_has_head();
}
inline const ::fantasybit::BlockHeader& Block::head() const {
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::fantasybit::BlockHeader* Block::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::fantasybit::BlockHeader;
  return head_;
}
inline ::fantasybit::BlockHeader* Block::release_head() {
  clear_has_head();
  ::fantasybit::BlockHeader* temp = head_;
  head_ = NULL;
  return temp;
}
inline void Block::set_allocated_head(::fantasybit::BlockHeader* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
}

// repeated .fantasybit.SignedTransaction signed_transactions = 20;
inline int Block::signed_transactions_size() const {
  return signed_transactions_.size();
}
inline void Block::clear_signed_transactions() {
  signed_transactions_.Clear();
}
inline const ::fantasybit::SignedTransaction& Block::signed_transactions(int index) const {
  return signed_transactions_.Get(index);
}
inline ::fantasybit::SignedTransaction* Block::mutable_signed_transactions(int index) {
  return signed_transactions_.Mutable(index);
}
inline ::fantasybit::SignedTransaction* Block::add_signed_transactions() {
  return signed_transactions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::SignedTransaction >&
Block::signed_transactions() const {
  return signed_transactions_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::SignedTransaction >*
Block::mutable_signed_transactions() {
  return &signed_transactions_;
}

// -------------------------------------------------------------------

// SignedBlock

// optional int32 version = 1;
inline bool SignedBlock::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignedBlock::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignedBlock::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignedBlock::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 SignedBlock::version() const {
  return version_;
}
inline void SignedBlock::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// optional .fantasybit.Block block = 10;
inline bool SignedBlock::has_block() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignedBlock::set_has_block() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignedBlock::clear_has_block() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignedBlock::clear_block() {
  if (block_ != NULL) block_->::fantasybit::Block::Clear();
  clear_has_block();
}
inline const ::fantasybit::Block& SignedBlock::block() const {
  return block_ != NULL ? *block_ : *default_instance_->block_;
}
inline ::fantasybit::Block* SignedBlock::mutable_block() {
  set_has_block();
  if (block_ == NULL) block_ = new ::fantasybit::Block;
  return block_;
}
inline ::fantasybit::Block* SignedBlock::release_block() {
  clear_has_block();
  ::fantasybit::Block* temp = block_;
  block_ = NULL;
  return temp;
}
inline void SignedBlock::set_allocated_block(::fantasybit::Block* block) {
  delete block_;
  block_ = block;
  if (block) {
    set_has_block();
  } else {
    clear_has_block();
  }
}

// optional bytes id = 20;
inline bool SignedBlock::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignedBlock::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignedBlock::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignedBlock::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& SignedBlock::id() const {
  return *id_;
}
inline void SignedBlock::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SignedBlock::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SignedBlock::set_id(const void* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedBlock::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* SignedBlock::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedBlock::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sig = 30;
inline bool SignedBlock::has_sig() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignedBlock::set_has_sig() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignedBlock::clear_has_sig() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignedBlock::clear_sig() {
  if (sig_ != &::google::protobuf::internal::kEmptyString) {
    sig_->clear();
  }
  clear_has_sig();
}
inline const ::std::string& SignedBlock::sig() const {
  return *sig_;
}
inline void SignedBlock::set_sig(const ::std::string& value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void SignedBlock::set_sig(const char* value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void SignedBlock::set_sig(const char* value, size_t size) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedBlock::mutable_sig() {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  return sig_;
}
inline ::std::string* SignedBlock::release_sig() {
  clear_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sig_;
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedBlock::set_allocated_sig(::std::string* sig) {
  if (sig_ != &::google::protobuf::internal::kEmptyString) {
    delete sig_;
  }
  if (sig) {
    set_has_sig();
    sig_ = sig;
  } else {
    clear_has_sig();
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fantasybit

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::OutData_Type>() {
  return ::fantasybit::OutData_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::InData_Type>() {
  return ::fantasybit::InData_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::MyNameStatus>() {
  return ::fantasybit::MyNameStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::TransType>() {
  return ::fantasybit::TransType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ProtoData_2eproto__INCLUDED
